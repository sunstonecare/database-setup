create schema if not exists "shadow";

create table IF NOT EXISTS public._schema_versions (
                                                     current_version character(14) not null UNIQUE,
                                                     previous_version character(14) UNIQUE REFERENCES _schema_versions(current_version),
                                                     constraint "_schema_versions_check" CHECK (current_version > previous_version)
);
CREATE UNIQUE INDEX IF NOT EXISTS i_schema_versions ON public._schema_versions USING btree (((previous_version IS NULL))) WHERE (previous_version IS NULL);

create table "public"."person" (
    "id" integer generated by default as identity not null
);


create table "public"."test_table" (
    "id" integer generated by default as identity not null,
    "display_name" text generated always as (COALESCE(((first_name || ' '::text) || last_name), first_name, last_name)) stored,
    "first_name" text,
    "last_name" text
);


create table "shadow"."person" (
    "shadow_person_id" integer,
    "action" character varying,
    "action_time" timestamp with time zone,
    "id" integer
);


create table "shadow"."test_table" (
    "shadow_person_id" integer,
    "action" character varying,
    "action_time" timestamp with time zone,
    "id" integer,
    "display_name" text,
    "first_name" text,
    "last_name" text
);


CREATE UNIQUE INDEX person_pkey ON public.person USING btree (id);

CREATE INDEX test ON public.test_table USING btree (id) INCLUDE (first_name);

CREATE UNIQUE INDEX test_table_pkey ON public.test_table USING btree (id);

alter table "public"."person" add constraint "person_pkey" PRIMARY KEY using index "person_pkey";

alter table "public"."test_table" add constraint "test_table_pkey" PRIMARY KEY using index "test_table_pkey";

alter table "shadow"."person" add constraint "person_person_id" FOREIGN KEY (shadow_person_id) REFERENCES person(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED not valid;

alter table "shadow"."person" validate constraint "person_person_id";

alter table "shadow"."test_table" add constraint "test_table_person_id" FOREIGN KEY (shadow_person_id) REFERENCES person(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED not valid;

alter table "shadow"."test_table" validate constraint "test_table_person_id";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_shadow(source_schema name, source_table name, shadow_schema name DEFAULT NULL::name, shadow_table name DEFAULT NULL::name)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  r           RECORD;
  version     RECORD;
  trigger_def RECORD;
BEGIN
  IF source_schema IS NULL THEN
    RAISE EXCEPTION 'Must specify source schema: add_shadow(source_schema, source_table, shadow_schema, shadow_table)';
  END IF;
  IF source_table IS NULL THEN
    RAISE EXCEPTION 'Must specify source table: add_shadow(source_schema, source_table, shadow_schema, shadow_table)';
  END IF;
  IF shadow_schema IS NULL THEN
    shadow_schema := source_schema;
  END IF;
  IF shadow_table IS NULL THEN
    shadow_table := source_table || '_s';
  END IF;

  -- Check to see if source table already exists
  SELECT table_schema, table_name INTO r
  FROM information_schema.tables
  WHERE table_schema = source_schema AND table_name = source_table;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Source Table must exist (%.%)', source_schema, source_table;
  END IF;

  -- Check to see if shadow table already exists
  SELECT table_schema, table_name INTO r
  FROM information_schema.tables   
  WHERE table_schema = shadow_schema AND table_name = shadow_table;

  IF FOUND THEN
    RAISE NOTICE 'Shadow Table already exist (%.%)', shadow_schema, shadow_table;
  END IF;

  -- Check to see if triggers already exist
  -- Need to check the object source because the same trigger name may exist more than once in a schema if applied to different tables.
  SELECT trigger_schema, trigger_name
  INTO r
  FROM information_schema.triggers
  WHERE trigger_schema = source_schema
    AND trigger_name IN (LOWER(source_table) || '_tsi', 
                         LOWER(source_table) || '_tsu', 
                         LOWER(source_table) || '_tsd',
                         LOWER(source_table) || '_tss')
    AND event_object_schema = source_schema
    AND event_object_table = source_table;

  IF FOUND THEN
    RAISE EXCEPTION 'Trigger already exist (%.%)', r.trigger_schema, r.trigger_name;
  END IF;

  -- Create Shadow Table
  EXECUTE 'CREATE TABLE ' || QUOTE_IDENT(shadow_schema) || '.' || QUOTE_IDENT(shadow_table) ||
          ' AS SELECT NULL::INT AS shadow_person_id, ''INSERT''::varchar AS action, now() AS action_time, * FROM ' ||
          QUOTE_IDENT(source_schema) || '.' || QUOTE_IDENT(source_table);

  EXECUTE 'ALTER TABLE ' || QUOTE_IDENT(shadow_schema) || '.' || QUOTE_IDENT(shadow_table) ||
          ' ADD CONSTRAINT ' || shadow_table || '_person_id FOREIGN KEY (shadow_person_id) REFERENCES public.person (id)' ||
          ' ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;';

  IF source_schema IN ('institution', 'client') THEN
    EXECUTE format('ALTER TABLE %I.%I ADD CONSTRAINT %s_%s_id FOREIGN KEY (%s_id) REFERENCES public.%s (id) ON DELETE CASCADE;',
      shadow_schema, shadow_table, shadow_table, source_schema, source_schema, source_schema);

    EXECUTE format('CREATE INDEX ON %I.%I (%s_id)', shadow_schema, shadow_table, source_schema);
  END IF;

  -- Add Triggers
  EXECUTE 'CREATE TRIGGER ' || LOWER(source_table) || '_tsi AFTER INSERT ON ' || QUOTE_IDENT(source_schema) || '.' ||
          QUOTE_IDENT(source_table) ||
          ' REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE public.shadow(' ||
          QUOTE_LITERAL(shadow_schema) || ', ' || QUOTE_LITERAL(shadow_table) || ')';

  EXECUTE 'CREATE TRIGGER ' || LOWER(source_table) || '_tsu AFTER UPDATE ON ' || QUOTE_IDENT(source_schema) || '.' ||
          QUOTE_IDENT(source_table) ||
          ' REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE public.shadow(' ||
          QUOTE_LITERAL(shadow_schema) || ', ' || QUOTE_LITERAL(shadow_table) || ')';

  EXECUTE 'CREATE TRIGGER ' || LOWER(source_table) || '_tsd AFTER DELETE ON ' || QUOTE_IDENT(source_schema) || '.' ||
          QUOTE_IDENT(source_table) ||
          ' REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE PROCEDURE public.shadow(' ||
          QUOTE_LITERAL(shadow_schema) || ', ' || QUOTE_LITERAL(shadow_table) || ')';

  EXECUTE 'CREATE TRIGGER ' || LOWER(source_table) || '_tss BEFORE TRUNCATE ON ' || QUOTE_IDENT(source_schema) ||
          '.' || QUOTE_IDENT(source_table) || ' FOR EACH STATEMENT EXECUTE PROCEDURE public.shadow(' ||
          QUOTE_LITERAL(shadow_schema) || ', ' || QUOTE_LITERAL(shadow_table) || ')';

  --EXECUTE 'CREATE INDEX ON ' || quote_ident(shadow_schema) || '.' || quote_ident(shadow_table) ||
  --        ' USING btree (id, action_time DESC);';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_shadow_to_all_tables()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  shadow_schema TEXT;
  shadow_table  TEXT;
  local_schema  TEXT;
BEGIN
  FOR shadow_schema, shadow_table IN SELECT table_schema, table_name
                                     FROM information_schema.tables
                                     WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
                                       AND table_schema NOT LIKE 'pg_toast%'
                                       AND table_schema NOT LIKE '%shadow%'
                                       AND table_schema NOT LIKE '%cron%'
                                       AND table_name <> '_schema_versions'
                                       AND table_type = 'BASE TABLE'
    LOOP
      local_schema := 'shadow';
      IF shadow_schema != 'public' THEN
        local_schema := shadow_schema || '_shadow';
        PERFORM schema_name FROM information_schema.schemata WHERE schema_name = local_schema;
        IF NOT FOUND THEN
          EXECUTE 'CREATE SCHEMA IF NOT EXISTS ' || local_schema;
        END IF;
      END IF;

      PERFORM FROM information_schema.tables WHERE table_schema = local_schema AND table_name = shadow_table;
      IF NOT FOUND THEN
        PERFORM add_shadow(shadow_schema, shadow_table, local_schema, shadow_table);
      END IF;
    END LOOP;

END
$function$
;

CREATE OR REPLACE FUNCTION public.get_person_id()
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE
AS $function$
  SELECT 1;
$function$
;

CREATE OR REPLACE FUNCTION public.shadow()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  shadow_schema TEXT;
  shadow_table  TEXT;
BEGIN
  IF (TG_NARGS <> 2) THEN
    RAISE EXCEPTION 'Incorrect number of arguments for shadow_function(schema, table): %', TG_NARGS;
  END IF;

  shadow_schema = TG_ARGV[0];
  shadow_table = TG_ARGV[1];
  IF TG_OP IN ('INSERT', 'UPDATE') AND TG_LEVEL = 'ROW' THEN
    EXECUTE 'INSERT INTO ' || QUOTE_IDENT(shadow_schema) || '.' || QUOTE_IDENT(shadow_table) ||
            ' SELECT public.get_person_id(), $2 , now(), $1.*' USING TG_OP, NEW;
    RETURN NEW;
  ELSIF TG_OP IN ('INSERT', 'UPDATE') AND TG_LEVEL = 'STATEMENT' THEN

    -- Add exemptions here
    -- IF shadow_schema = 'client_shadow' THEN
    --   PERFORM * FROM client c, new_table o WHERE c.id=o.client_id;
    --   IF NOT FOUND THEN RETURN OLD; END IF;
    -- END IF;

    -- IF shadow_schema = 'institution_shadow' THEN      
    --   PERFORM * FROM institution i, new_table o WHERE i.id=o.institution_id;
    --   IF NOT FOUND THEN RETURN OLD; END IF;
    -- END IF;
    
    EXECUTE 'INSERT INTO ' || QUOTE_IDENT(shadow_schema) || '.' || QUOTE_IDENT(shadow_table) ||
            ' SELECT public.get_person_id(), $1 , now(), n.* FROM new_table n' USING TG_OP;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' AND TG_LEVEL = 'ROW' THEN
    EXECUTE 'INSERT INTO ' || QUOTE_IDENT(shadow_schema) || '.' || QUOTE_IDENT(shadow_table) ||
            ' SELECT public.get_person_id(), $2 , now(), $1.*' USING TG_OP, OLD;
    RETURN OLD;
  ELSIF TG_OP = 'DELETE' AND TG_LEVEL = 'STATEMENT' THEN

    -- Add exemptions here
    -- IF shadow_schema = 'client_shadow' THEN
    --   PERFORM * FROM client c, old_table o WHERE c.id=o.client_id;
    --   IF NOT FOUND THEN RETURN OLD; END IF;
    -- END IF;

    -- IF shadow_schema = 'institution_shadow' THEN      
    --   PERFORM * FROM institution i, old_table o WHERE i.id=o.institution_id;
    --   IF NOT FOUND THEN RETURN OLD; END IF;
    -- END IF;

    IF shadow_table = 'institution' THEN 
      PERFORM * FROM institution i, old_table o WHERE i.id=o.id;
      IF NOT FOUND THEN RETURN OLD; END IF;
    END IF;
        
    EXECUTE 'INSERT INTO ' || QUOTE_IDENT(shadow_schema) || '.' || QUOTE_IDENT(shadow_table) ||
            ' SELECT public.get_person_id(), $1 , now(), o.* FROM old_table o' USING TG_OP;

    RETURN OLD;
  ELSIF TG_OP = 'TRUNCATE' THEN
    EXECUTE 'INSERT INTO ' || QUOTE_IDENT(shadow_schema) || '.' || QUOTE_IDENT(shadow_table) ||
            ' (shadow_person_id, action, action_time) VALUES (public.get_person_id(), $1 , now())' USING TG_OP;
    RETURN NULL;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE TRIGGER person_tsd AFTER DELETE ON public.person REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'person');

CREATE TRIGGER person_tsi AFTER INSERT ON public.person REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'person');

CREATE TRIGGER person_tss BEFORE TRUNCATE ON public.person FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'person');

CREATE TRIGGER person_tsu AFTER UPDATE ON public.person REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'person');

CREATE TRIGGER test_table_tsd AFTER DELETE ON public.test_table REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_table');

CREATE TRIGGER test_table_tsi AFTER INSERT ON public.test_table REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_table');

CREATE TRIGGER test_table_tss BEFORE TRUNCATE ON public.test_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_table');

CREATE TRIGGER test_table_tsu AFTER UPDATE ON public.test_table REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_table');
-- PERMISSIONS
GRANT SELECT ON test_table TO current_user;-- END PERMISSIONS
