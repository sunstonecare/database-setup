create table "public"."test_2" (
    "id" integer generated by default as identity not null
);


create table "shadow"."test_2" (
    "shadow_person_id" integer,
    "action" character varying,
    "action_time" timestamp with time zone,
    "id" integer
);


CREATE UNIQUE INDEX test_2_pkey ON public.test_2 USING btree (id);

alter table "public"."test_2" add constraint "test_2_pkey" PRIMARY KEY using index "test_2_pkey";

alter table "shadow"."test_2" add constraint "test_2_person_id" FOREIGN KEY (shadow_person_id) REFERENCES person(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED not valid;

alter table "shadow"."test_2" validate constraint "test_2_person_id";

CREATE TRIGGER test_2_tsd AFTER DELETE ON public.test_2 REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_2');

CREATE TRIGGER test_2_tsi AFTER INSERT ON public.test_2 REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_2');

CREATE TRIGGER test_2_tss BEFORE TRUNCATE ON public.test_2 FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_2');

CREATE TRIGGER test_2_tsu AFTER UPDATE ON public.test_2 REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE FUNCTION shadow('shadow', 'test_2');
-- PERMISSIONS
GRANT SELECT ON test_table TO current_user;-- END PERMISSIONS

-- VERIFICATION
DO
$$
  DECLARE
    new_m5 TEXT;

  BEGIN
    new_m5:= (SELECT MD5(STRING_AGG(current_version || '.' || previous_version, ','))::TEXT FROM _schema_versions);

    ASSERT new_m5 ='57fd3708e880975c18e6c8b09c23e28f', format('MD5 of migrations: 57fd3708e880975c18e6c8b09c23e28f does not equal %s, something fishy is going on, aborting.', new_m5);
  END
$$ LANGUAGE plpgsql;
-- END VERIFICATION
